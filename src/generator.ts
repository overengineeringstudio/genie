import * as Cli from '@effect/cli'
import { FileSystem, HttpClient, Path } from '@effect/platform'
import { NodeContext, NodeHttpClient, NodeRuntime } from '@effect/platform-node'
import { Data, Effect, Layer, Match, Schema } from 'effect'

import { compile } from 'json-schema-to-typescript'
import { ConverterConfig, GeneratorConfig } from './config-defs.js'
import { config } from './libs.js'

const LIB_PATH = './src/lib'

//
// Errors
//
class GenerateTypesError extends Data.TaggedError('GenerateTypesError')<{
  readonly message: string
  readonly cause: unknown
}> {}

//
// Helper functions
//
const fetchJsonSchema = Effect.fn('fetchJsonSchema')(function* (
  converterConfig: ConverterConfig,
) {
  const client = yield* HttpClient.HttpClient

  yield* Effect.logInfo(
    `Fetching JSON Schema from ${converterConfig.source.url} ...`,
  )

  const response = yield* client.get(converterConfig.source.url)

  yield* Effect.logInfo(
    `Fetched JSON Schema from ${converterConfig.source.url}.`,
  )

  return (yield* response.json) as object
})

const generateTypesFromJsonSchema = Effect.fn('generateTypesFromJsonSchema')(
  function* (jsonSchema: object, converterConfig: ConverterConfig) {
    // We tale the convert id and remove a possible name suffix out of it.
    // For example, when the id is `package-json`, we remove the `-json` suffix,
    // if the `output.format` is `json`.
    const prefix = converterConfig.id
      .replace(converterConfig.output._tag, '')
      .replace(/-/g, '')

    // Then we take the extracted prefix, the output format and PascalCase them
    // to derive the name of the main type. In the end: `package-json` becomes `PackageJSON`.
    const name = `${prefix.charAt(0).toUpperCase()}${prefix.slice(1)}${converterConfig.output._tag.toUpperCase()}`
    const mainTypeName = `${name}Args`

    // We have to inject the title into the schema because it then gets
    // We have to inject the title into the schema because it then gets
    // used by json-schema-to-typescript to name the main type.
    const compilableSchema = {
      ...jsonSchema,
      title: mainTypeName,
    } as const

    const types = yield* Effect.tryPromise({
      try: () =>
        compile(compilableSchema, name, {
          bannerComment:
            '/** This file is generated by genie. Do not edit it manually. */',
          format: false,
          strictIndexSignatures: true,
        }),
      catch: (cause) =>
        new GenerateTypesError({
          message: `Failed to generate types of JSON Schema "${converterConfig.id}" (url: ${converterConfig.source.url})`,
          cause,
        }),
    })

    return {
      name,
      mainTypeName,
      types,
    } as const
  },
)

const generateConverterFunction = Effect.fn('generateConverterFunction')(
  function* (converterConfig: ConverterConfig) {
    yield* Effect.logInfo(`Generating code for "${converterConfig.name}" ...`)

    const types = yield* Match.value(converterConfig.source._tag).pipe(
      Match.when('json-schema', () =>
        Effect.gen(function* () {
          const jsonSchema = yield* fetchJsonSchema(converterConfig)
          const types = yield* generateTypesFromJsonSchema(
            jsonSchema,
            converterConfig,
          )

          return types
        }),
      ),
      Match.exhaustive,
    )

    // The function name, e.g. `PackageJSON` becomes `packageJSON`.
    const functionName = `${types.mainTypeName.charAt(0).toLowerCase()}${types.name.slice(1)}`

    const contents = `
${types.types}

/**
 * ${converterConfig.description ?? `Creates a ${types.name} configuration object`}
 * @param args ${types.mainTypeName} configuration options
 * @returns A properly formatted configuration object
 */
export const ${functionName} = (
    args: ${types.mainTypeName},
): string => {
    return JSON.stringify({
    "$schema": "${converterConfig.source.url}",
    ...(typeof args === 'string' ? {} : args)
    }, null, 2)
}
    `

    yield* Effect.logInfo(`Generated code for "${converterConfig.name}".`)

    return {
      fileName: `${converterConfig.id}.ts`,
      functionName,
      contents,
    } as const
  },
)

const writeConverterFunction = Effect.fn('writeConverterFunction')(function* (
  fileName: string,
  contents: string,
) {
  const fs = yield* FileSystem.FileSystem
  const path = yield* Path.Path

  yield* fs.writeFile(
    path.join(LIB_PATH, fileName),
    new TextEncoder().encode(contents),
  )

  // Make the file read-only
  yield* fs.chmod(path.join(LIB_PATH, fileName), 0o444)

  yield* Effect.logInfo(`Generated ${fileName}.`)
})

const generateModuleEntrypoint = Effect.fn('generateModuleEntrypoint')(
  function* (dto: { fileName: string; functionName: string }[]) {
    const fs = yield* FileSystem.FileSystem
    const path = yield* Path.Path

    const contents = dto
      .map(
        ({ fileName, functionName }) =>
          `export { ${functionName} } from './${fileName.replace('.ts', '.js')}'`,
      )
      .join('\n')

    return contents
  },
)

const writeModuleEntrypoint = Effect.fn('writeModuleEntrypoint')(function* (
  contents: string,
) {
  const fs = yield* FileSystem.FileSystem
  const path = yield* Path.Path

  yield* fs.writeFile(
    path.join(LIB_PATH, 'mod.ts'),
    new TextEncoder().encode(contents),
  )

  // Make the file read-only
  yield* fs.chmod(path.join(LIB_PATH, 'mod.ts'), 0o444)

  yield* Effect.logInfo('Generated module entrypoint.')
})

const generate = Effect.fn('generate')(function* (config: GeneratorConfig) {
  const fs = yield* FileSystem.FileSystem

  const generateAllConverterFunctions = config.converters.map(
    generateConverterFunction,
  )

  const converterFunctions = yield* Effect.all(generateAllConverterFunctions, {
    concurrency: 'unbounded',
  })

  // `force` is required to avoid errors when the directory does not exist.
  yield* fs.remove(LIB_PATH, { recursive: true, force: true })
  yield* fs.makeDirectory(LIB_PATH, { recursive: true })

  const writeAllConverterFunctions = converterFunctions.map(
    (converterFunction) =>
      writeConverterFunction(
        converterFunction.fileName,
        converterFunction.contents,
      ),
  )

  yield* Effect.all(writeAllConverterFunctions, { concurrency: 'unbounded' })

  const moduleEntrypointContents =
    yield* generateModuleEntrypoint(converterFunctions)
  yield* writeModuleEntrypoint(moduleEntrypointContents)
})

//
// CLI
//

const cli = Cli.Command.make(
  'genie-generator',
  {
    cwd: Cli.Options.text('cwd').pipe(Cli.Options.withDefault(process.cwd())),
  },
  Effect.fn(function* () {
    yield* generate(config).pipe(Effect.scoped)

    yield* Effect.logInfo('âœ… Done.')
  }),
)

Cli.Command.run(cli, {
  name: 'Genie Generator',
  version: '0.0.0',
})(process.argv).pipe(
  Effect.provide(Layer.mergeAll(NodeHttpClient.layer, NodeContext.layer)),
  NodeRuntime.runMain,
)
